#include <stdlib.h>

typedef int row3_t[3];
typedef row3_t array4_3_t[5];

array4_3_t A;

int get_value(array4_3_t A, int i, int j)
{
    return A[i][j];
}

row3_t row0, row1, row2, row3;
int *B[4] = {row0, row1, row2, row3};

int get_value2(int *B[4], int i, int  j)
{
    return B[i][j];
}

/* $begin fixmatrixdef-c */
#define N 16
typedef int fix_matrix[N][N];
/* $end fixmatrixdef-c */

fix_matrix *new_fix_matrix(int n) {
    return (fix_matrix *) malloc(sizeof(fix_matrix));
}

/* $begin fixprodele-c */
/* Compute i,k of fixed matrix product */
int fix_prod_ele (fix_matrix A, fix_matrix B,  int i, int k) {
    int j;
    int result = 0;

    for (j = 0; j < N; j++)
	result += A[i][j] * B[j][k];

    return result;
}
/* $end fixprodele-c */

/* $begin fixprodeleopt-c */
/* Compute i,k of fixed matrix product */
int fix_prod_ele_opt(fix_matrix A, fix_matrix B, int i, int k) {
    int *Arow = &A[i][0];
    int *Bptr = &B[0][k];
    int result = 0;
    int j;
    for (j = 0; j != N; j++) {
	result += Arow[j] * *Bptr;
	Bptr += N;
    }
    return result;
}
/* $end fixprodeleopt-c */

/* $begin fixdiag-c */
/* Set all diagonal elements to val */
void fix_set_diag(fix_matrix A, int val) {
  int i;
  for (i = 0; i < N; i++)
    A[i][i] = val;
}
/* $end fixdiag-c */

/* $begin fixdiagopt-c */
/* Set all diagonal elements to val */
void fix_set_diag_opt(fix_matrix A, int val) {
  int *Abase = &A[0][0];
  int index = 0;
  do {
    Abase[index] = val;
    index += (N+1);
  } while (index != (N+1)*N);
}
/* $end fixdiagopt-c */

int fix_ele(fix_matrix A, int i, int j) {
    return A[i][j];
}

/* $begin newvarmatrix-c */
void *new_var_matrix(int n) {
    return malloc(sizeof(int[n][n]));
}
/* $end newvarmatrix-c */

/* $begin varele-c */
int var_ele(int n, int A[n][n], int i, int j) {
    return A[i][j];
}
/* $end varele-c */

/* Demonstrate how you would access a matrix generated by malloc */
int pvar_ele(int n, void *p, int i, int j) {
    return var_ele(n, p, i, j);
}

/* $begin varprodele-c */
/* Compute i,k of variable matrix product */
int var_prod_ele(int n, int A[n][n], int B[n][n], int i, int k) {
    int j;
    int result = 0;

    for (j = 0; j < n; j++)
	result += A[i][j] * B[j][k]; //line:asm:array:varprodaccess

    return result;
}
/* $end varprodele-c */

/* $begin varprodeleopt-c */
/* Compute i,k of variable matrix product */
int var_prod_ele_opt(int n, int A[n][n], int B[n][n], int i, int k) {
    int *Arow = A[i];
    int *Bptr = &B[0][k];
    int result = 0;
    int j;
    for (j = 0; j < n; j++) {
        result += Arow[j] * *Bptr;
	Bptr += n;
    }
    return result;
}
/* $end varprodeleopt-c */

